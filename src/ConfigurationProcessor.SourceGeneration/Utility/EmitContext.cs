using System.Globalization;
using System.Reflection;
using System.Text;

namespace ConfigurationProcessor.SourceGeneration.Utility;

internal record class EmitContext(string Namespace, List<Assembly> References)
{
    private const string SingleIndent = "   ";
    private string currentIndent = string.Empty;
    private readonly List<string> createdTypes = new();
    private readonly HashSet<string> namespaces = new(StringComparer.Ordinal)
    {
        "Microsoft.Extensions.Configuration",
    };

    public StringBuilder StringBuilder { get; } = new StringBuilder();

    public Dictionary<string, List<Type>> TypeMap { get; } = References.SelectMany(x => x.GetExportedTypes()).GroupBy(x => x.FullName).ToDictionary(x => x.Key, x => x.ToList());

    public string[]? ImplicitSuffixes { get; set; }

    public void AddNamespace(string ns)
        => namespaces.Add(ns);

    public void IncreaseIndent()
        => currentIndent += SingleIndent;

    public void DecreaseIndent()
        => currentIndent = currentIndent.Substring(0, currentIndent.Length - SingleIndent.Length);

    public void Write(string lines)
    {
        var split = lines.Split(new[] { Environment.NewLine }, StringSplitOptions.None);
        foreach (var line in split)
        {
            if (string.IsNullOrEmpty(line))
            {
                StringBuilder.AppendLine();
            }
            else
            {
                StringBuilder.Append(currentIndent);
                StringBuilder.AppendLine(line);
            }
        }
    }

    public override string ToString()
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        foreach (var ns in namespaces)
        {
            sb.AppendFormat(
                @"using {0};
",
                ns);
        }

        sb.AppendLine();
        sb.AppendLine(StringBuilder.ToString());

        foreach (var classDefinition in createdTypes)
        {
            sb.AppendLine(classDefinition);
        }

        return sb.ToString();
    }

    internal Type CreateType(string newTypeName)
    {
        createdTypes.Add($"internal sealed class {newTypeName} {{ }}");
        return new FakeClass(newTypeName, Namespace);
    }

    internal Type CreateType(string newTypeName, Type baseType)
    {
        createdTypes.Add($"internal sealed class {newTypeName} : {baseType.FullName} {{ }}");
        return new FakeClass(newTypeName, Namespace, baseType);
    }

    private sealed class FakeClass : Type
    {
        public FakeClass(string name, string ns, Type? baseType = null)
        {
            Name = name;
            Namespace = ns;
            BaseType = baseType!;
        }

        public override Assembly Assembly => throw new NotImplementedException();

        public override string AssemblyQualifiedName => throw new NotImplementedException();

        public override Type BaseType { get; }

        public override string FullName => throw new NotImplementedException();

        public override Guid GUID => throw new NotImplementedException();

        public override Module Module => throw new NotImplementedException();

        public override string Namespace { get; }

        public override Type UnderlyingSystemType => throw new NotImplementedException();

        public override string Name { get; }

        public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr)
        {
            throw new NotImplementedException();
        }

        public override object[] GetCustomAttributes(bool inherit)
        {
            throw new NotImplementedException();
        }

        public override object[] GetCustomAttributes(Type attributeType, bool inherit)
        {
            throw new NotImplementedException();
        }

        public override Type GetElementType()
        {
            throw new NotImplementedException();
        }

        public override EventInfo GetEvent(string name, BindingFlags bindingAttr)
        {
            throw new NotImplementedException();
        }

        public override EventInfo[] GetEvents(BindingFlags bindingAttr)
        {
            throw new NotImplementedException();
        }

        public override FieldInfo GetField(string name, BindingFlags bindingAttr)
        {
            throw new NotImplementedException();
        }

        public override FieldInfo[] GetFields(BindingFlags bindingAttr)
        {
            throw new NotImplementedException();
        }

        public override Type GetInterface(string name, bool ignoreCase)
        {
            throw new NotImplementedException();
        }

        public override Type[] GetInterfaces()
        {
            throw new NotImplementedException();
        }

        public override MemberInfo[] GetMembers(BindingFlags bindingAttr)
        {
            throw new NotImplementedException();
        }

        public override MethodInfo[] GetMethods(BindingFlags bindingAttr)
        {
            throw new NotImplementedException();
        }

        public override Type GetNestedType(string name, BindingFlags bindingAttr)
        {
            throw new NotImplementedException();
        }

        public override Type[] GetNestedTypes(BindingFlags bindingAttr)
        {
            throw new NotImplementedException();
        }

        public override PropertyInfo[] GetProperties(BindingFlags bindingAttr)
        {
            throw new NotImplementedException();
        }

        public override object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters)
        {
            throw new NotImplementedException();
        }

        public override bool IsDefined(Type attributeType, bool inherit)
        {
            throw new NotImplementedException();
        }

        protected override TypeAttributes GetAttributeFlagsImpl()
        {
            throw new NotImplementedException();
        }

        protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
        {
            throw new NotImplementedException();
        }

        protected override MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers)
        {
            throw new NotImplementedException();
        }

        protected override PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers)
        {
            throw new NotImplementedException();
        }

        protected override bool HasElementTypeImpl()
        {
            throw new NotImplementedException();
        }

        protected override bool IsArrayImpl()
        {
            throw new NotImplementedException();
        }

        protected override bool IsByRefImpl()
        {
            throw new NotImplementedException();
        }

        protected override bool IsCOMObjectImpl()
        {
            throw new NotImplementedException();
        }

        protected override bool IsPointerImpl()
        {
            throw new NotImplementedException();
        }

        protected override bool IsPrimitiveImpl()
        {
            throw new NotImplementedException();
        }
    }
}
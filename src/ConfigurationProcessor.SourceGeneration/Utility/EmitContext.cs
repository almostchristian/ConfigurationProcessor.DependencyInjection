using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;

namespace ConfigurationProcessor.SourceGeneration.Utility;

internal record class EmitContext(IAssemblySymbol CurrentAssembly, string Namespace, List<Assembly> References, ReflectionPathAssemblyResolver AssemblyResolver)
{
    private int currentIndent = 0;
    private readonly HashSet<string> createdTypes = new();
    private readonly HashSet<string> namespaces = new(StringComparer.Ordinal)
    {
        "Microsoft.Extensions.Configuration",
    };

    public StringBuilder StringBuilder { get; } = new StringBuilder();

    public Dictionary<string, List<Type>> TypeMap { get; } = References.SelectMany(x => x.GetExportedTypes()).GroupBy(x => x.FullName).ToDictionary(x => x.Key, x => x.ToList());

    public string[]? ImplicitSuffixes { get; set; }

    public void AddNamespace(string ns)
        => namespaces.Add(ns);

    public void IncreaseIndent()
        => currentIndent += 3;

    public void DecreaseIndent()
        => currentIndent -= 3;

    public void Write(string lines)
    {
        var split = lines.Split(new[] { Environment.NewLine }, StringSplitOptions.None);
        foreach (var line in split)
        {
            if (string.IsNullOrEmpty(line))
            {
                StringBuilder.AppendLine();
            }
            else
            {
                StringBuilder.Append(' ', currentIndent);
                StringBuilder.AppendLine(line);
            }
        }
    }

    public override string ToString()
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        foreach (var ns in namespaces)
        {
            sb.AppendFormat(
                """
                using {0};

                """,
                ns);
        }

        sb.AppendLine();
        sb.AppendLine(StringBuilder.ToString());

        foreach (var classDefinition in createdTypes)
        {
            sb.AppendLine(classDefinition);
        }

        return sb.ToString();
    }

    internal Type CreateType(string newTypeName)
    {
        createdTypes.Add($"internal sealed class {newTypeName} {{ }}");
        return CreateFakeType(newTypeName, Namespace, null);
    }

    internal Type CreateType(string newTypeName, Type baseType)
    {
        createdTypes.Add($"internal sealed class {newTypeName} : {baseType.FullName} {{ }}");
        return CreateFakeType(newTypeName, Namespace, baseType);
    }

    private static Type CreateFakeType(string fakeTypeName, string @namespace, Type? baseType)
    {
        return new FakeType(fakeTypeName, @namespace, baseType);
    }
}
